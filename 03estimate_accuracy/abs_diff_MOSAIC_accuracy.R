
library(data.table)
library(argparse)
library(dplyr)
library(MOSAIC)
"%&%" = function(a,b) paste(a,b,sep="")

parser <- ArgumentParser()
parser$add_argument("--rdata", help="Rdata object ouput by MOSAIC")
parser$add_argument("--intermediate", help="path to intermediate folder generated by mosaic wrapper containing inputs of mosaic run")
parser$add_argument("--haps.sample", help="admixed samle list as in MOSAIC intermediate files")
parser$add_argument("--nancestries", help="number of ancestries")
parser$add_argument("--anc", help="ancestry id")
parser$add_argument("--result", help="results file output by adsimr")
parser$add_argument("--bim", help="admixed bim file")
parser$add_argument("--out", help="file you would like to output as")
args <- parser$parse_args()



#Read in snp ids
print("processing snp ids")
bim<-fread(args$bim, header = F, drop = c("V2", "V3","V5","V6"))
dim(bim)
colnames(bim)<-c("chm","pos")

#read in true ancestry and keep only snps found in bim file
print("reading in  true ancestry")
res<-as.data.frame(fread(args$result,header = T, showProgress = T))
true_ancestry_subset<-inner_join(bim,res,by=c("chm","pos"))

##read in and convert MOSAIC grid to snp level ancestries
print("Processing MOSAIC ancestry")
load(args$rdata)
local_pos=grid_to_pos(localanc,args$intermediate,g.loc,chrnos=22)

snp_count_true<-nrow(true_ancestry_subset)
nanc<-as.numeric(args$nanc)
n_haps<-(ncol(true_ancestry_subset) - 2)
nindv<-n_haps/2

true_ancestry_decomposed_haploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*n_haps)
mos_ancestry_decomposed_haploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*n_haps)

decompose_hap_to_ancestries<-function(haplotype, nanc){
  decomposed_anc<-matrix(,nrow = nrow(haplotype),ncol = nanc)
  anc1<-ifelse(haplotype==1,1,0)
  anc2<-ifelse(haplotype==2,1,0)
  decomposed_anc[,1]<-anc1
  decomposed_anc[,2]<-anc2
  if (nanc == 3){
    anc3<-ifelse(haplotype==3,1,0)
    decomposed_anc[,3]<-anc3
    return(decomposed_anc)
  } else {
    return(decomposed_anc)
  }
}


print("separating haplotypes into composite ancestries")
for (i in c(1:n_haps)){
  j<-i+2
  k<-i*nanc
  if(nanc==3){
    storage_indices<-c(k-2,k-1,k)
  } else {
    storage_indices<-c(k-1,k)
  }
  true_ancestry_decomposed_haploid[,storage_indices]<-decompose_hap_to_ancestries(select(true_ancestry_subset, c(j)),nanc)
  mos_ancestry_decomposed_haploid[,storage_indices]<-local_pos[[1]][,i,] %>% t()
}

true_ancestry_decomposed_diploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*nindv)
mos_ancestry_decomposed_diploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*nindv)

print("converting haploid to diploid")
for (i in c(1:nindv)){
  k<-i*nanc*2
  j<-i*nanc
  
  if(nanc==3){
    hap1_indices<-c(k-5,k-4,k-3)
    hap2_indices<-c(k-2,k-1,k)
    storage_indices<-c(j-2,j-1,j)
  } else {
    hap1_indices<-c(k-3,k-2)
    hap2_indices<-c(k-1,k)
    storage_indices<-c(j-1,j)
  }
  
  hap1<-true_ancestry_decomposed_haploid[,hap1_indices]
  hap2<-true_ancestry_decomposed_haploid[,hap2_indices]
  dip<-(hap1 + hap2)
  true_ancestry_decomposed_diploid[,storage_indices]<-dip
  
  moshap1<-mos_ancestry_decomposed_haploid[,hap1_indices]
  moshap2<-mos_ancestry_decomposed_haploid[,hap2_indices]
  mosdip<-(moshap1 + moshap2)
  mos_ancestry_decomposed_diploid[,storage_indices]<-mosdip
}

hap_corr<-c(rep(NA,n_haps))
dip_corr<-c(rep(NA,nindv))
anc_corr<-c(rep(NA,nindv*nanc))
str(mos_ancestry_decomposed_diploid)
#fwrite(as.data.frame(mos_ancestry_decomposed_diploid),"~/data/test_mos_dip.txt",sep="\t")
print("correlating diploid")
for (i in c(1:nindv)){
  cat(i,"\n")
  j<-i*nanc
  threshold<-(1/nanc)
  if(nanc==3){
    storage_indices<-c(j-2,j-1,j)
    flip<-c(2,3,1)
  } else {
    storage_indices<-c(j-1,j)
    flip<-c(2,1)
  }
  mos_indiv_i<-mos_ancestry_decomposed_diploid[,storage_indices]
  if (args$anc == "AFA"){
    mos_indiv_i<-mos_indiv_i<-mos_indiv_i[,flip]
  }
  
  true_indiv_i<-true_ancestry_decomposed_diploid[,storage_indices]
  corr<-sum(abs(mos_indiv_i - true_indiv_i))/2
  if (nanc == 3){
    mos_indiv_i<-mos_indiv_i[,flip]
    #str(mos_indiv_i)
    corr<-sum(abs(mos_indiv_i - true_indiv_i))/3
  }
  if(i == 1) {
    fwrite(mos_indiv_i,"/home/rschubert1/data/Local_ancestry_project/redoancestry/mos_indiv_i.txt")
    fwrite(true_indiv_i,"/home/rschubert1/data/Local_ancestry_project/redoancestry/true_indiv_i.txt")
  }

  dip_corr[i]<-corr
  j<-i*nanc
  if(nanc==3){
    storage_indices<-c(j-2,j-1,j)
    corr1<-cor.test(mos_ancestry_decomposed_diploid[,j],true_ancestry_decomposed_diploid[,j-1], method="pearson") #3 vs 2
    corr2<-cor.test(mos_ancestry_decomposed_diploid[,j-1],true_ancestry_decomposed_diploid[,j-2], method="pearson") #2 vs 1
    corr3<-cor.test(mos_ancestry_decomposed_diploid[,j-2],true_ancestry_decomposed_diploid[,j], method="pearson") # 1 vs 3
    # if (corr1$estimate < 0){
    #   corr1<-cor.test(mos_ancestry_decomposed_diploid[,j-2],true_ancestry_decomposed_diploid[,j-2], method="pearson")
    #   corr2<-cor.test(mos_ancestry_decomposed_diploid[,j-1],true_ancestry_decomposed_diploid[,j-1], method="pearson")
    # }
    anc_corr[storage_indices]<-c(corr1$estimate,corr2$estimate,corr3$estimate)
  } else {
    storage_indices<-c(j-1,j)
    corr1<-cor.test(mos_ancestry_decomposed_diploid[,j-1],true_ancestry_decomposed_diploid[,j-1], method="pearson")
    corr2<-cor.test(mos_ancestry_decomposed_diploid[,j],true_ancestry_decomposed_diploid[,j], method="pearson")
    # if (corr1$estimate < 0){
    #   corr1<-cor.test(mos_ancestry_decomposed_diploid[,j-1],true_ancestry_decomposed_diploid[,j-1], method="pearson")
    #   corr2<-cor.test(mos_ancestry_decomposed_diploid[,j],true_ancestry_decomposed_diploid[,j], method="pearson")
    # }
    anc_corr[storage_indices]<-c(corr1$estimate,corr2$estimate)
  }
}
# quit()
anc_corr; dip_corr
fwrite(as.list(dip_corr),args$out,sep ="\t")

# 
# print("calculating haploid accuracy")
# hap_cor<-c(rep(NA,40))
# #create two empty data frames to fill with diploid ancestries
# diploid_true<-data.frame(matrix(ncol = 20,nrow=50000))
# local_df<-data.frame(matrix(ncol = 20,nrow=50000))
# #convert haploid ancestries to diploid ancestries
# 
# if (args$nancestries == 3){
#   random<-c(1,2,3)
#   for ( i in c(1:20)){ 
#     cat( i, "/20\n")
#     hap2<-i*2
#     hap1<-hap2-1
#     #MOSAIC ancestries are stored in n_ancestries x n_haplotypes x n_snps matrix
#     #select dosage of anc1 for all snps in hap1 of indiv i. Round these dosages either to 0 or 1. Do same for anc2 and anc3 but assign them distinct values
#     anc1<-round(local_pos[[1]][1,hap1,])
#     anc2<-round(local_pos[[1]][2,hap1,]); anc2[anc2==1]<-2
#     anc3<-round(local_pos[[1]][3,hap1,]); anc3[anc3==1]<-3
#     #create a single numeric vector of ancestry for hap 1
#     hap1_ancestries<-ifelse(anc1==1,anc1,ifelse(anc2==2,anc2,anc3))
#     hap1_ancestries[hap1_ancestries==0]<-sample(random,1)
#     #select dosage of anc1 for all snps in hap2 of indiv i. Round these dosages either to 0 or 1. Do same for anc2 and anc3 but assign them distinct values
#     anc1<-round(local_pos[[1]][1,hap2,])
#     anc2<-round(local_pos[[1]][2,hap2,]); anc2[anc2==1]<-2
#     anc3<-round(local_pos[[1]][3,hap2,]); anc3[anc3==1]<-3
#     #create a single numeric vector of ancestry for hap 2
#     hap2_ancestries<-ifelse(anc1==1,anc1,ifelse(anc2==2,anc2,anc3))
#     hap2_ancestries[hap2_ancestries==0]<-sample(random,1)
#     #paste together the two haplotypes into one vector of two character strings
#     diploid_anc<-paste(hap1_ancestries,hap2_ancestries, sep = "")
#     #flip ancestries to keep things fair with LAMPLD
#     diploid_anc<-gsub("32","23",gsub("31","13",gsub("21","12",diploid_anc)))
#     #encode each ancestry as a number
#     diploid_anc[diploid_anc == "11"] <- 1
#     diploid_anc[diploid_anc == "12"] <- 2
#     diploid_anc[diploid_anc == "13"] <- 3
#     diploid_anc[diploid_anc == "22"] <- 4
#     diploid_anc[diploid_anc == "23"] <- 5
#     diploid_anc[diploid_anc == "33"] <- 6
#     local_df[,i]<-as.numeric(diploid_anc)
#     
#     #repeat process for results df
#     dip_t<-paste(res[,hap1+2],res[,hap2+2],sep="")
#     dip_t<-gsub("32","23",gsub("31","13",gsub("21","12",dip_t)))
#     dip_t[dip_t == "11"] <- 1
#     dip_t[dip_t == "12"] <- 2
#     dip_t[dip_t == "13"] <- 3
#     dip_t[dip_t == "22"] <- 4
#     dip_t[dip_t == "23"] <- 5
#     dip_t[dip_t == "33"] <- 6
#     dip_t<-as.numeric(dip_t)
#     diploid_true[,i]<-dip_t
#     hap_cor[hap1]<-cor.test(hap1_ancestries,res[,hap1+2],method="pearson")[[4]]
#     hap_cor[hap2]<-cor.test(hap2_ancestries,res[,hap2+2],method="pearson")[[4]]
#   }
# } else if (args$nancestries ==2){
#   random<-c(1,2)
#   for ( i in c(1:20)){ 
#     cat( i, "/ 20\n")
#     hap2<-i*2
#     hap1<-hap2-1
#     anc1<-round(local_pos[[1]][1,hap1,])
#     anc2<-round(local_pos[[1]][2,hap1,]); anc2[anc2==1]<-2
#     hap1_ancestries<-ifelse(anc1==1,anc1,anc2)
#     hap1_ancestries[hap1_ancestries==0]<-sample(random,1)
#     anc1<-round(local_pos[[1]][1,hap2,])
#     anc2<-round(local_pos[[1]][2,hap2,]); anc2[anc2==1]<-2
#     hap2_ancestries<-ifelse(anc1==1,anc1,anc2)
#     hap2_ancestries[hap2_ancestries==0]<-sample(random,1)
#     diploid_anc<-paste(hap1_ancestries,hap2_ancestries, sep = "")
#     diploid_anc<-gsub("21","12",diploid_anc)
#     diploid_anc[diploid_anc == "11"] <- 1
#     diploid_anc[diploid_anc == "12"] <- 2
#     diploid_anc[diploid_anc == "22"] <- 3
#     local_df[,i]<-as.numeric(diploid_anc)
#     
#     dip_t<-paste(res[,hap1+2],res[,hap2+2],sep="")
#     dip_t<-gsub("21","12",dip_t)
#     dip_t[dip_t == "11"] <- 1
#     dip_t[dip_t == "12"] <- 2
#     dip_t[dip_t == "22"] <- 3
#     diploid_true[,i]<-as.numeric(dip_t)
#     
#     hap_cor[hap1]<-cor.test(hap1_ancestries,res[,hap1+2],method="pearson")[[4]]
#     hap_cor[hap2]<-cor.test(hap2_ancestries,res[,hap2+2],method="pearson")[[4]]
#   }
# }
# hap_cor[is.na(hap_cor)]<-1.01
# fwrite(as.list(hap_cor),args$out %&% "_hap_accuracy.txt", sep ="\t", col.names = F)
# ## assign snp ids to MOSAIC
# local_df<-as.data.frame(cbind.data.frame(bim,local_df))
# #colnames(local_df)<-c("chm","pos",ids)
# diploid_true<-as.data.frame(cbind.data.frame(bim,diploid_true))
# ##read in known ancestry, make sure it has only the right snp, and cols in the right order
# #fwrite(local_df)
# 
# #sanity check
# print("MOS dim:")
# dim(local_df)
# str(local_df)
# print("actual dim")
# dim(diploid_true)
# str(diploid_true)
# # fwrite(diploid_true,"~/software/Local_Ancestry/MOS_test_True.txt", sep = "\t")
# # fwrite(local_df,"~/software/Local_Ancestry/MOS_test_estimated.txt", sep = "\t")
# #begin corr tests per haplotype
# corrs<-c(rep(0,20))
# for (i in c(1:20)){
#   corrs[i]<-cor.test(local_df[,(i+2)],diploid_true[,(i+2)],method="pearson")[[4]]
#   # print(sd(local_df[,(i+2)]))
#   # print(sd(diploid_true[,(i+2)]))
# }
# warnings()
# corrs[is.na(corrs)]<-1.01
# str(corrs)
# #fwrite(local_df,"~/software/Local_Ancestry/Local_DF.txt",col.names = T,sep='\t' )
# #process and write to file
# corr_R2<-corrs*corrs
# 
# print("writing corrs")
# fwrite(as.list(corrs),args$out %&% "_dip_accuracy.txt",sep="\t")
# print("writing corr R2")
# corr_R2<-as.list(corr_R2)
# str(corr_R2)
# fwrite(corr_R2,args$out %&% "_dip_accuracy.txt",sep="\t
