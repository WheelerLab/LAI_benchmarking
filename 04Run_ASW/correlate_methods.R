###script to correlate between methods

library(data.table)
library(argparse)
library(dplyr)
library(MOSAIC)
"%&%" = function(a,b) paste(a,b,sep="")

parser <- ArgumentParser()
parser$add_argument("--viterbi", help="Rdata object ouput by RFMix")
parser$add_argument("--long", help="Rdata object ouput by LAMPLD")
parser$add_argument("--rdata", help="Rdata object ouput by MOSAIC")
parser$add_argument("--ps.21", help="resultant output of ELAI")
parser$add_argument("--loter", help="Loter results file")
parser$add_argument("--nanc", help="number of ancestries estimated")
parser$add_argument("--intermediate", help="path to intermediate folder generated by mosaic wrapper containing inputs of mosaic run")
parser$add_argument("--bim", help="admixed bim file")
parser$add_argument("--out", help="file you would like to output as")
args <- parser$parse_args()


decompose_hap_to_ancestries<-function(haplotype, nanc, method){
  if (method == "Loter" | method == "LAMPLD"){
    index = 0
  } 
  else if (method == "MOSAIC" | method == "RFMix" | method =="ELAI"){
    index = 1
  } 
  else {
    print("Error: method not specified or supported, qutting.")
    quit(1)
  }
  decomposed_anc<-matrix(NA,nrow = nrow(haplotype),ncol = nanc)
  anc1<-ifelse(haplotype==index,1,0)
  anc2<-ifelse(haplotype==(index + 1),1,0)
  decomposed_anc[,1]<-anc1
  decomposed_anc[,2]<-anc2
  if (nanc == 3){
    anc3<-ifelse(haplotype==(index + 2),1,0)
    decomposed_anc[,3]<-anc3
    return(decomposed_anc)
  } else {
    return(decomposed_anc)
  }
}

print("processing snp ids")
snps<-fread(args$bim, header = F, drop = c("V2", "V3","V5","V6"))
dim(snps)
colnames(snps)<-c("chm","pos")

print("Processing RFMix ancestry")
rfout<-fread(args$viterbi, header = F)
rfout<-as.data.frame(cbind.data.frame(snps,rfout))


print("determining dimensions from RFMix output")
n_haps<-(ncol(rfout) - 2)
nindv<-n_haps/2
snp_count_true<-nrow(rfout)
nanc<-as.numeric(args$nanc)


rf_ancestry_decomposed_haploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*n_haps)
rf_ancestry_decomposed_diploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*nindv)

print("separating haplotypes into composite ancestries")
for (i in c(1:40)){
  j<-i+2
  k<-i*nanc
  if(nanc==3){
    storage_indices<-c(k-2,k-1,k)
  } else {
    storage_indices<-c(k-1,k)
  }
  rf_ancestry_decomposed_haploid[,storage_indices]<-decompose_hap_to_ancestries(select(rfout, c(j)),nanc,method="RFMix")
}
print("converting haploid to diploid")
for (i in c(1:20)){
  k<-i*nanc*2
  j<-i*nanc
  
  if(nanc==3){
    hap1_indices<-c(k-5,k-4,k-3)
    hap2_indices<-c(k-2,k-1,k)
    storage_indices<-c(j-2,j-1,j)
  } else {
    hap1_indices<-c(k-3,k-2)
    hap2_indices<-c(k-1,k)
    storage_indices<-c(j-1,j)
  }
  rfhap1<-rf_ancestry_decomposed_haploid[,hap1_indices]
  rfhap2<-rf_ancestry_decomposed_haploid[,hap2_indices]
  rfdip<-(rfhap1 + rfhap2)
  rf_ancestry_decomposed_diploid[,storage_indices]<-rfdip
}

print("Processing MOSAIC ancestry")
load(args$rdata)
local_pos=grid_to_pos(localanc,args$intermediate,g.loc,chrnos=22)

mos_ancestry_decomposed_haploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*n_haps)
mos_ancestry_decomposed_diploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*nindv)

print("separating haplotypes into composite ancestries")
for (i in c(1:40)){
  j<-i+2
  k<-i*nanc
  if(nanc==3){
    storage_indices<-c(k-2,k-1,k)
  } else {
    storage_indices<-c(k-1,k)
  }
  mos_ancestry_decomposed_haploid[,storage_indices]<-local_pos[[1]][,i,] %>% t()
}

print("converting haploid to diploid")
for (i in c(1:20)){
  k<-i*nanc*2
  j<-i*nanc
  
  if(nanc==3){
    hap1_indices<-c(k-5,k-4,k-3)
    hap2_indices<-c(k-2,k-1,k)
    storage_indices<-c(j-2,j-1,j)
  } else {
    hap1_indices<-c(k-3,k-2)
    hap2_indices<-c(k-1,k)
    storage_indices<-c(j-1,j)
  }
  moshap1<-mos_ancestry_decomposed_haploid[,hap1_indices]
  moshap2<-mos_ancestry_decomposed_haploid[,hap2_indices]
  mosdip<-(moshap1 + moshap2)
  mos_ancestry_decomposed_diploid[,storage_indices]<-mosdip
}

print("Processing Loter ancestry")

loterout<-fread(args$loter, header = F) %>% t() %>% as.data.frame()
loterout<-as.data.frame(cbind.data.frame(snps,loterout))

loter_ancestry_decomposed_haploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*n_haps)
loter_ancestry_decomposed_diploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*nindv)

print("separating haplotypes into composite ancestries")
for (i in c(1:40)){
  j<-i+2
  k<-i*nanc
  if(nanc==3){
    storage_indices<-c(k-2,k-1,k)
  } else {
    storage_indices<-c(k-1,k)
  }
  loter_ancestry_decomposed_haploid[,storage_indices]<-decompose_hap_to_ancestries(select(loterout, c(j)),nanc,method="Loter")
}

print("converting haploid to diploid")
for (i in c(1:20)){
  k<-i*nanc*2
  j<-i*nanc
  
  if(nanc==3){
    hap1_indices<-c(k-5,k-4,k-3)
    hap2_indices<-c(k-2,k-1,k)
    storage_indices<-c(j-2,j-1,j)
  } else {
    hap1_indices<-c(k-3,k-2)
    hap2_indices<-c(k-1,k)
    storage_indices<-c(j-1,j)
  }
  loterhap1<-loter_ancestry_decomposed_haploid[,hap1_indices]
  loterhap2<-loter_ancestry_decomposed_haploid[,hap2_indices]
  loterdip<-(loterhap1 + loterhap2)
  loter_ancestry_decomposed_diploid[,storage_indices]<-loterdip
}


print("Processing LAMPLD ancestry")
long<-fread(args$long, header = F)
long<-strsplit(long$V1,"")
long<-matrix(unlist(long), nrow=length(long), byrow=T)  %>% t()
long<-apply(long,2,as.numeric) %>% as.data.frame(stringsAsFactors = F) 

LAMPLD_ancestry_decomposed_haploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*n_haps)
LAMPLD_ancestry_decomposed_diploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*nindv)

print("separating haplotypes into composite ancestries")
## calc both true and maximized
for (i in c(1:40)){
  j<-i+2
  k<-i*nanc
  if(nanc==3){
    storage_indices<-c(k-2,k-1,k)
  } else {
    storage_indices<-c(k-1,k)
  }
  LAMPLD_ancestry_decomposed_haploid[,storage_indices]<-decompose_hap_to_ancestries(select(long, c(i)),nanc,method ="LAMPLD")
  
}

print("converting haploid to diploid")
for (i in c(1:20)){
  k<-i*nanc*2
  j<-i*nanc
  
  if(nanc==3){
    hap1_indices<-c(k-5,k-4,k-3)
    hap2_indices<-c(k-2,k-1,k)
    storage_indices<-c(j-2,j-1,j)
  } else {
    hap1_indices<-c(k-3,k-2)
    hap2_indices<-c(k-1,k)
    storage_indices<-c(j-1,j)
  }
  
  LAMPLDhap1<-LAMPLD_ancestry_decomposed_haploid[,hap1_indices]
  LAMPLDhap2<-LAMPLD_ancestry_decomposed_haploid[,hap2_indices]
  LAMPLDdip<-(LAMPLDhap1 + LAMPLDhap2)
  LAMPLD_ancestry_decomposed_diploid[,storage_indices]<-LAMPLDdip
}


print("Processing ELAI ancestry")

elai_out<-as.data.frame(fread(args$ps.21,header = F))
elai_ancestry_decomposed_diploid<-matrix(NA,nrow=snp_count_true,ncol=nanc*nindv)
ncols<-ncol(elai_out)
anc1_index<-seq(1, ncols, nanc)
anc2_index<-seq(2, ncols, nanc)
if(nanc==3){
  anc3_index<-seq(3, ncols, nanc)
}

print("converting haploid to diploid and reformatting elai output")
for (i in c(1:20)){
  cat(i,"\n")
  k<-i*nanc*2
  j<-i*nanc
  if(nanc==3){
    hap1_indices<-c(k-5,k-4,k-3)
    hap2_indices<-c(k-2,k-1,k)
    storage_indices<-c(j-2,j-1,j)
  } else {
    hap1_indices<-c(k-3,k-2)
    hap2_indices<-c(k-1,k)
    storage_indices<-c(j-1,j)
  }
  
  anc1_dosage<-elai_out[i,anc1_index]
  anc2_dosage<-elai_out[i,anc2_index]
  colnames(anc2_dosage)<-colnames(anc1_dosage)
  if (nanc ==3 ){
    anc3_dosage<-elai_out[i,anc3_index]
    colnames(anc3_dosage)<-colnames(anc1_dosage)
    indiv<-rbind(anc1_dosage,rbind(anc2_dosage,anc3_dosage)) %>% t()
  } else{
    indiv<-rbind(anc1_dosage,anc2_dosage) %>% t()
  }
  # str(indiv)
  elai_ancestry_decomposed_diploid[,storage_indices]<-indiv 
}

tokens<-c("elai_ancestry_decomposed_diploid","LAMPLD_ancestry_decomposed_diploid","loter_ancestry_decomposed_diploid","rf_ancestry_decomposed_diploid","mos_ancestry_decomposed_diploid")

corr_mat<-matrix(NA,nrow=length(tokens),ncol=length(tokens))
colnames(corr_mat)<-tokens
rownames(corr_mat)<-tokens
for (i in tokens){
  for (j in tokens){
    t1<-get(i)
    t2<-get(j)
    corr<-cor.test(c(t1),c(t2))
    corr_mat[i,j]<-corr$estimate
  }
}

fwrite(corr_mat,args$out,col.names = T,row.names = T,quote=F,sep="\t")

